<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SDL_学习</title>
    <url>/2025/01/31/SDL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="图片渲染"><a href="#图片渲染" class="headerlink" title="图片渲染"></a>图片渲染</h2><ol>
<li><p>定义一块区域</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Rect rect = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1680</span>, <span class="number">1080</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>获取图片</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Surface* img_surf = <span class="built_in">IMG_Load</span>(<span class="string">&quot;D:/Coding/Project/source/background.png&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!img_surf) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IMG_Load Error: %s\n&quot;</span>, <span class="built_in">IMG_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>绘制纹理</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Texture* img_texture = <span class="built_in">SDL_CreateTextureFromSurface</span>(renderer, img_surf);</span><br><span class="line"><span class="built_in">SDL_FreeSurface</span>(img_surf); <span class="comment">// 释放表面</span></span><br><span class="line"><span class="keyword">if</span> (!img_texture) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SDL_CreateTextureFromSurface Error: %s\n&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝至渲染器</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderCopy</span>(renderer, img_texture, <span class="literal">NULL</span>, &amp;rect);</span><br></pre></td></tr></table></figure></li>
<li><p>显示渲染内容</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderPresent</span>(renderer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理资源</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_DestroyTexture</span>(img_texture);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h2><ol>
<li><p>初始化 TTF 库</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">TTF_Init</span>() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TTF_Init Error: %s\n&quot;</span>, <span class="built_in">TTF_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义字体对象</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TTF_Font* font = <span class="built_in">TTF_OpenFont</span>(<span class="string">&quot;D:/Coding/Project/fonts/arial.ttf&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">if</span> (!font) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TTF_OpenFont Error: %s\n&quot;</span>, <span class="built_in">TTF_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建文字表面</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Color color = &#123;<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>&#125;; <span class="comment">// 白色</span></span><br><span class="line">SDL_Surface* text_surf = <span class="built_in">TTF_RenderText_Solid</span>(font, <span class="string">&quot;Hello, SDL!&quot;</span>, color);</span><br><span class="line"><span class="keyword">if</span> (!text_surf) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TTF_RenderText_Solid Error: %s\n&quot;</span>, <span class="built_in">TTF_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建文字纹理</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Texture* text_texture = <span class="built_in">SDL_CreateTextureFromSurface</span>(renderer, text_surf);</span><br><span class="line"><span class="built_in">SDL_FreeSurface</span>(text_surf); <span class="comment">// 释放表面</span></span><br><span class="line"><span class="keyword">if</span> (!text_texture) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SDL_CreateTextureFromSurface Error: %s\n&quot;</span>, <span class="built_in">SDL_GetError</span>());</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义文字显示区域</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Rect text_rect = &#123;x, y, text_surf-&gt;w, text_surf-&gt;h&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝文字纹理至渲染器</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderCopy</span>(renderer, text_texture, <span class="literal">NULL</span>, &amp;text_rect);</span><br></pre></td></tr></table></figure></li>
<li><p>显示渲染内容</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderPresent</span>(renderer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理资源</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_DestroyTexture</span>(text_texture);</span><br><span class="line"><span class="built_in">TTF_CloseFont</span>(font);</span><br><span class="line"><span class="built_in">TTF_Quit</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><ol>
<li>定义区域 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_Rect rect = &#123;x, y, width, height&#125;;</span><br></pre></td></tr></table></figure></li>
<li>设置绘制颜色 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_SetRenderDrawColor</span>(renderer, r, g, b, a);</span><br></pre></td></tr></table></figure></li>
<li>绘制矩形 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderFillRect</span>(renderer, &amp;rect);</span><br></pre></td></tr></table></figure></li>
<li>显示渲染内容 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_RenderPresent</span>(renderer);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="创建音频"><a href="#创建音频" class="headerlink" title="创建音频"></a>创建音频</h2><ol>
<li>加载音乐 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mix_Music* music = <span class="built_in">Mix_LoadMUS</span>(<span class="string">&quot;music.mp3&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>淡入播放音乐 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mix_FadeInMusic</span>(music, <span class="number">-1</span>, <span class="number">1500</span>);</span><br><span class="line"><span class="comment">/*-1：这是循环播放的次数。-1 表示无限循环播放音乐。</span></span><br><span class="line"><span class="comment">1500：这是淡入的时间，以毫秒为单位。这里表示音乐将在 1500 毫秒（1.5 秒）内从静音逐渐增加到全音量。*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>图形学习</category>
      </categories>
      <tags>
        <tag>SDL</tag>
        <tag>图像处理</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>rational.h</title>
    <url>/2025/01/11/rational/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113802808919811&bvid=BV1ojcne1E4s&cid=27790740871&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h1 id="rational-h-文件内容"><a href="#rational-h-文件内容" class="headerlink" title="rational.h 文件内容"></a>rational.h 文件内容</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _RATIONAL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RATIONAL_H_</span></span><br><span class="line"><span class="comment">//  大冰块stupid吗 2025-1-28  //讨论：未央  //指导：袁同学  //协助测试：郦同学</span></span><br><span class="line"><span class="comment">//  这有理库包含分数结构、常量、运算、输入、输出和转化等基本功能。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  辅助宏：类型改名，本库认为辅助宏最后必须销毁。</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ul unsigned long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lr longrat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义类型rational，三个成员分别是：分子、非负的分母、化简状态。\</span></span><br><span class="line"><span class="comment">//  当splfd(simplified)的值为1时，认为一个rat已经被化简过，此外，\</span></span><br><span class="line"><span class="comment">    您也可以通过将splfd赋值为1来保护一个rat，或者搞破坏。splfd仅\</span></span><br><span class="line"><span class="comment">    1 bit大小，在一个rat 未 初始化时可能导致错误。\</span></span><br><span class="line"><span class="comment">//  rat.down为unsigned类型，请留意补码造成的隐患。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">struct rat&#123;</span></span><br><span class="line">    <span class="type">int</span> up; <span class="type">unsigned</span> down: <span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">8</span><span class="number">-1</span>; <span class="type">unsigned</span> splfd: <span class="number">1</span>;</span><br><span class="line">&#125;;  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rat</span> <span class="title">rat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  为了保证longrat的精度比rat高，这里使用条件编译。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">struct longrat&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &lt; LONG_MAX</span></span><br><span class="line">    <span class="type">long</span> up; ul down: <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">8</span><span class="number">-1</span>; ul splfd: <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ll up; ull down: <span class="keyword">sizeof</span>(ll)*<span class="number">8</span><span class="number">-1</span>; ull splfd: <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">longrat</span> <span class="title">longrat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据#include本库前是否#define _AUTO_RAT_TYPE_\</span></span><br><span class="line"><span class="comment">    本库分为 手动类型调整 模式 和 自动类型调整 模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  默认模式，\</span></span><br><span class="line"><span class="comment">    即手动类型调整模式，本库对rat和longrat的一切函数参数与返回\</span></span><br><span class="line"><span class="comment">    值进行严格区分，如果想让不同精度rational变量混合传参，必须\</span></span><br><span class="line"><span class="comment">    手动转化，本库提供了转化函数，您当然可以自行写语句做转化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  自动类型调整模式，\</span></span><br><span class="line"><span class="comment">    本库中的大量糖衣宏被激活，自动将传入函数的rational类型强行\</span></span><br><span class="line"><span class="comment">    统一，使混合传参（仅rats）成为可能。由于糖衣宏的展开行为，\</span></span><br><span class="line"><span class="comment">    代码中某些只出现 一次 的有理数据 将变得 多次 出现，如果这有\</span></span><br><span class="line"><span class="comment">    理数恰是本库函数的返回值，糖衣宏的展开就会产生不必要的重复\</span></span><br><span class="line"><span class="comment">    调用，拖慢效率并带来隐患（例如一个输入函数因宏展开而被调用\</span></span><br><span class="line"><span class="comment">    多次）。若使用_AUTO_RAT_TYPE_，建议 *回避* 函数的 *嵌套*。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义常量：0、1、分数式的正无穷、负无穷、不定态（即NaN）等，\</span></span><br><span class="line"><span class="comment">    后三个不妨统称无值分数。另外，推荐经常利用(l)rZERO做初始化。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">const rat      rZERO=&#123;0,1,1&#125;,  rONE=&#123;1,1,1&#125;,  rINF=&#123;1,0,1&#125;,  rNEGINF=&#123;-1,0,1&#125;,  rUNCERTAIN=&#123;0,0,1&#125;;</span></span><br><span class="line"><span class="type">const</span> longrat  lrZERO=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, lrONE=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, lrINF=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;, lrNEGINF=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;, lrUNCERTAIN=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数式的长短rat转化。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">rat torat(lr);</span></span><br><span class="line">lr <span class="title function_">tolr</span><span class="params">(rat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  运算：最大公约数、最小公倍数、约分、加、负、减、乘、倒、除、二元运算包、绝对值、比较。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">ll gcd(ll,ll);          ull lcm(ll,ll);</span></span><br><span class="line">lr <span class="title function_">lrsplfy</span><span class="params">(lr)</span>;         rat <span class="title function_">rsplfy</span><span class="params">(rat)</span>;</span><br><span class="line">lr <span class="title function_">lrplus</span><span class="params">(lr,lr)</span>;       rat <span class="title function_">rplus</span><span class="params">(rat,rat)</span>;</span><br><span class="line">lr <span class="title function_">lrneg</span><span class="params">(lr)</span>;           rat <span class="title function_">rneg</span><span class="params">(rat)</span>;</span><br><span class="line">lr <span class="title function_">lrminus</span><span class="params">(lr,lr)</span>;      rat <span class="title function_">rminus</span><span class="params">(rat,rat)</span>;</span><br><span class="line">lr <span class="title function_">lrtime</span><span class="params">(lr,lr)</span>;       rat <span class="title function_">rtime</span><span class="params">(rat,rat)</span>;</span><br><span class="line">lr <span class="title function_">lrflip</span><span class="params">(lr)</span>;          rat <span class="title function_">rflip</span><span class="params">(rat)</span>;</span><br><span class="line">lr <span class="title function_">lrdivi</span><span class="params">(lr,lr)</span>;       rat <span class="title function_">rdivi</span><span class="params">(rat,rat)</span>;</span><br><span class="line">lr <span class="title function_">co2lr</span><span class="params">(lr,<span class="type">char</span>,lr)</span>;   rat <span class="title function_">co2r</span><span class="params">(rat,<span class="type">char</span>,rat)</span>;</span><br><span class="line">lr <span class="title function_">lrabs</span><span class="params">(lr)</span>;           rat <span class="title function_">rabs</span><span class="params">(rat)</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">lrcmp</span><span class="params">(lr,lr)</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">rcmp</span><span class="params">(rat,rat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出：分数、指定位数小数、（循环）小数。输入：综合、分数、（循环）小数。转化：到浮点、到整数。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">char lrap(lr);          char rap(rat);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fltlrap</span><span class="params">(lr,<span class="type">int</span>)</span>;    <span class="type">int</span> <span class="title function_">fltrap</span><span class="params">(rat,<span class="type">int</span>)</span>;</span><br><span class="line">ll <span class="title function_">lrdeci</span><span class="params">(lr)</span>;          <span class="type">int</span> <span class="title function_">rdeci</span><span class="params">(rat)</span>;</span><br><span class="line">lr <span class="title function_">getlr</span><span class="params">()</span>;             rat <span class="title function_">getrat</span><span class="params">()</span>;</span><br><span class="line">lr <span class="title function_">getlfrac</span><span class="params">()</span>;          rat <span class="title function_">getfrac</span><span class="params">()</span>;</span><br><span class="line">lr <span class="title function_">getldeci</span><span class="params">()</span>;          rat <span class="title function_">getdeci</span><span class="params">()</span>;    </span><br><span class="line"><span class="type">double</span> <span class="title function_">lrtodb</span><span class="params">(lr)</span>;      <span class="type">double</span> <span class="title function_">rattodb</span><span class="params">(rat)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rattoint</span><span class="params">(rat)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>     INT_MAX &lt; LONG_MAX</span></span><br><span class="line"><span class="type">long</span>    <span class="title function_">lrtolong</span><span class="params">(lr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">ll      <span class="title function_">lrtoll</span><span class="params">(lr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  辅助宏：输出非负整数(++i)、输出检查、是否空白、是否数码、循环添位、小数添位、输入截停。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PUTU_PPI_(n,i)&#123;\</span></span><br><span class="line"><span class="meta">    ull ten=1,lv=2,m=n;\</span></span><br><span class="line"><span class="meta">    while(n/=10) ten*=10,++lv;\</span></span><br><span class="line"><span class="meta">    while(--lv)&#123;\</span></span><br><span class="line"><span class="meta">        putchar(m/ten+<span class="string">&#x27;0&#x27;</span>);\</span></span><br><span class="line"><span class="meta">        m%=ten;ten/=10;++i;&#125;\</span></span><br><span class="line"><span class="meta">&#125;   <span class="comment">//  int lv=2;与--lv呼应。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PUTU_(n)&#123;\</span></span><br><span class="line"><span class="meta">    ull ten=1,lv=2,m=n;\</span></span><br><span class="line"><span class="meta">    while(n/=10) ten*=10,++lv;\</span></span><br><span class="line"><span class="meta">    while(--lv)&#123;\</span></span><br><span class="line"><span class="meta">        putchar(m/ten+<span class="string">&#x27;0&#x27;</span>);\</span></span><br><span class="line"><span class="meta">        m%=ten;ten/=10;&#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RAP_CHECK_1_(q)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(q.splfd!=1) q=lrsplfy(q);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!q.down)&#123;\</span></span><br><span class="line"><span class="meta">        switch(q.up)&#123;\</span></span><br><span class="line"><span class="meta">            case -1: fputs(<span class="string">&quot;-inf&quot;</span>,stdout);return 4;\</span></span><br><span class="line"><span class="meta">            case 0: fputs(<span class="string">&quot;NaN&quot;</span>,stdout);return 3;\</span></span><br><span class="line"><span class="meta">            case 1: fputs(<span class="string">&quot;+inf&quot;</span>,stdout);return 4;\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RAP_CHECK_2_(q)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(q.splfd!=1) q=lrsplfy(q);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!q.down)&#123;\</span></span><br><span class="line"><span class="meta">        switch(q.up)&#123;\</span></span><br><span class="line"><span class="meta">            case -1: fputs(<span class="string">&quot;-inf&quot;</span>,stdout);break;\</span></span><br><span class="line"><span class="meta">            case 0: fputs(<span class="string">&quot;NaN&quot;</span>,stdout);break;\</span></span><br><span class="line"><span class="meta">            case 1: fputs(<span class="string">&quot;+inf&quot;</span>,stdout);break;\</span></span><br><span class="line"><span class="meta">        &#125;   return 0;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_BLANK_(ch) (ch==<span class="string">&#x27; &#x27;</span>||ch==<span class="string">&#x27;\n&#x27;</span>||ch==<span class="string">&#x27;\t&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IS_DIGIT_(ch) (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ADD_DIGIT_(n,temp) while(_IS_DIGIT_(temp)) &#123;n=n*10+temp-<span class="string">&#x27;0&#x27;</span>; temp=getchar();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POINT_ADD_DIGIT_(up,down,temp) while(_IS_DIGIT_(temp)) &#123;up=up*10+temp-<span class="string">&#x27;0&#x27;</span>; down*=10; temp=getchar();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SHOULD_END_1_(q,temp) <span class="keyword">if</span>(temp!=<span class="string">&#x27;/&#x27;</span>&amp;&amp;temp!=<span class="string">&#x27;.&#x27;</span>) &#123;ungetc(temp,stdin); q.up*=pozneg; return q;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SHOULD_END_2_(q,temp) <span class="keyword">if</span>(temp!=<span class="string">&#x27;(&#x27;</span>) &#123;ungetc(temp,stdin); q.up*=pozneg; return q;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SHOULD_END_3_(q,temp) <span class="keyword">if</span>(temp!=<span class="string">&#x27;/&#x27;</span>) &#123;ungetc(temp,stdin); q.up*=pozneg; return q;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SHOULD_END_4_(q,temp) <span class="keyword">if</span>(temp!=<span class="string">&#x27;.&#x27;</span>) &#123;ungetc(temp,stdin); q.up*=pozneg; return q;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数实现和相关解释说明：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rational.c&quot;</span></span></span><br><span class="line"><span class="comment">//  请将.h.c放在同一目录下。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ul</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ull</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lr</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _PUTU_PPI_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _PUTU_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _RAP_CHECK_1_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _RAP_CHECK_2_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IS_BLANK_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IS_DIGIT_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _ADD_DIGIT_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _POINT_ADD_DIGIT_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _SHOULD_END_1_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _SHOULD_END_2_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _SHOULD_END_3_</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _SHOULD_END_4_</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="rational-c-文件内容"><a href="#rational-c-文件内容" class="headerlink" title="rational.c 文件内容"></a>rational.c 文件内容</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  在_AUTO_RAT_TYPE_模式下，为了让函数同时支持不同精度的rat，本库使用\</span></span><br><span class="line"><span class="comment">    了大量的糖衣宏，展开后，单个rat变成多个，如果它是函数的返回值，就造成\</span></span><br><span class="line"><span class="comment">    不必要的重复调用，故不推荐在 自动类型模式 嵌套函数（尤其是get(l)rat）。</span></span><br><span class="line"><span class="comment">//  默认模式，即 手动类型 模式下，您可随意做函数的嵌套。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*过渡为 rat*/</span></span><br><span class="line">rat _rat_(<span class="type">int</span> up,<span class="type">unsigned</span> down,<span class="type">char</span> splfd) &#123;rat q=&#123;up,down,splfd&#125;; <span class="keyword">return</span> q;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RAT_(q) _rat_((q).up,(q).down,(q).splfd)</span></span><br><span class="line">    <span class="comment">/*过渡为 longrat*/</span></span><br><span class="line">lr _lr_(ll up,ull down,<span class="type">char</span> splfd) &#123;lr q=&#123;up,down,splfd&#125;; <span class="keyword">return</span> q;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LR_(q) _lr_((q).up,(q).down,(q).splfd)</span></span><br><span class="line"><span class="comment">//  以上是自动模式下的 隐藏函数 和 糖衣宏。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 转为 rat*/</span></span><br><span class="line">rat <span class="title function_">torat</span><span class="params">(lr qq)</span> &#123;rat q=&#123;qq.up,qq.down,qq.splfd&#125;; <span class="keyword">return</span> q;&#125;</span><br><span class="line">    <span class="comment">/*rat 转为 longrat*/</span></span><br><span class="line">lr <span class="title function_">tolr</span><span class="params">(rat q)</span> &#123;lr qq=&#123;q.up,q.down,q.splfd&#125;; <span class="keyword">return</span> qq;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回值非负，且有gcd(0,n)==gcd(n,0)==n。</span></span><br><span class="line">    <span class="comment">/*最大公约数*/</span></span><br><span class="line">ll <span class="title function_">gcd</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">    ll temp;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">        temp=a%b,a=b,b=temp;</span><br><span class="line">    <span class="keyword">return</span> a&lt;<span class="number">0</span> ? -a:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  返回值非负，认为0与任何数的最小公倍数为0。</span></span><br><span class="line">    <span class="comment">/*最小公倍数*/</span></span><br><span class="line">ull <span class="title function_">lcm</span><span class="params">(ll a,ll b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a=-a;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>) b=-b;</span><br><span class="line">    ull aa=a,bb=b,temp;</span><br><span class="line">    <span class="keyword">while</span>(bb)</span><br><span class="line">        temp=aa%bb,aa=bb,bb=temp;</span><br><span class="line">    <span class="keyword">return</span> a/aa*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  做运算的有理数必须经过splfy(simplify)\</span></span><br><span class="line"><span class="comment">    检查，它使用形参，并有权更改rat.splfd。</span></span><br><span class="line">    <span class="comment">/*longrat 约分*/</span></span><br><span class="line">lr <span class="title function_">lrsplfy</span><span class="params">(lr q)</span>&#123;</span><br><span class="line"><span class="comment">//  无需化简，立即返回。</span></span><br><span class="line">    <span class="keyword">if</span>(q.splfd==<span class="number">1</span>) <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">if</span>(q.down==<span class="number">1</span>) <span class="keyword">return</span> q.splfd=<span class="number">1</span>,q;</span><br><span class="line"><span class="comment">//  单独处理uncertain的情况。</span></span><br><span class="line">    <span class="keyword">if</span>(!q.up&amp;&amp;!q.down)</span><br><span class="line">    <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line"><span class="comment">//  正无穷和负无穷能够被归纳。</span></span><br><span class="line">    ll temp=gcd(q.up,q.down);</span><br><span class="line">        q.up/=temp;</span><br><span class="line">        q.down/=temp;</span><br><span class="line">        q.splfd=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 约分*/</span></span><br><span class="line">rat <span class="title function_">rsplfy</span><span class="params">(rat q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.splfd==<span class="number">1</span>) <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">if</span>(q.down==<span class="number">1</span>) <span class="keyword">return</span> q.splfd=<span class="number">1</span>,q;</span><br><span class="line">    <span class="keyword">if</span>(!q.up&amp;&amp;!q.down)</span><br><span class="line">    <span class="keyword">return</span> rUNCERTAIN;</span><br><span class="line">    <span class="type">int</span> temp=gcd(q.up,q.down);</span><br><span class="line">        q.up/=temp;</span><br><span class="line">        q.down/=temp;</span><br><span class="line">        q.splfd=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 约分*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrsplfy(q) lrsplfy(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 约分*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rsplfy(q) rsplfy(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 加法*/</span></span><br><span class="line">lr <span class="title function_">lrplus</span><span class="params">(lr x,lr y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.splfd!=<span class="number">1</span>) x=lrsplfy(x);</span><br><span class="line">    <span class="keyword">if</span>(y.splfd!=<span class="number">1</span>) y=lrsplfy(y);</span><br><span class="line"><span class="comment">//  分母为零的无值分数。</span></span><br><span class="line">    <span class="keyword">if</span>(!x.down||!y.down)&#123;</span><br><span class="line">        <span class="comment">//只有一个无值分数则返回它。</span></span><br><span class="line">        <span class="keyword">if</span>(x.down) <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">if</span>(y.down) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">//认为同种无值分数之和不变。</span></span><br><span class="line">        <span class="keyword">if</span>(x.up==y.up) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">//不同的无值分数和为不定态。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  单独处理同分母。</span></span><br><span class="line">    <span class="keyword">if</span>(x.down==y.down)&#123;</span><br><span class="line">        x.up+=y.up;</span><br><span class="line"><span class="comment">//  各处强制化简前必将splfd置零。</span></span><br><span class="line">        <span class="keyword">if</span>(x.down!=<span class="number">1</span>)&#123;</span><br><span class="line">            x.splfd=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> lrsplfy(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  其中一方为零，立即返回另一方。</span></span><br><span class="line">    <span class="keyword">if</span>(!x.up)   <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(!y.up)   <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">unsigned</span> temp=lcm(x.down,y.down);</span><br><span class="line">    x.up=(<span class="type">int</span>)(temp/x.down)*x.up</span><br><span class="line">        +(<span class="type">int</span>)(temp/y.down)*y.up;</span><br><span class="line">    x.down=temp;</span><br><span class="line">    <span class="keyword">return</span> x.splfd=<span class="number">0</span>,lrsplfy(x);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 加法*/</span></span><br><span class="line">rat <span class="title function_">rplus</span><span class="params">(rat x,rat y)</span>&#123;</span><br><span class="line">    lr  xx=&#123;x.up,x.down,x.splfd&#125;,</span><br><span class="line">        yy=&#123;y.up,y.down,y.splfd&#125;;</span><br><span class="line">    xx=lrplus(xx,yy);</span><br><span class="line">    rat res=&#123;xx.up,xx.down,xx.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 加法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrplus(x,y) lrplus(_LR_(x),_LR_(y))</span></span><br><span class="line">    <span class="comment">/*rat 加法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rplus(x,y) rplus(_RAT_(x),_RAT_(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 求负*/</span></span><br><span class="line">lr <span class="title function_">lrneg</span><span class="params">(lr q)</span> &#123;<span class="keyword">return</span> q.up=-q.up,q;&#125;</span><br><span class="line">    <span class="comment">/*rat 求负*/</span></span><br><span class="line">rat <span class="title function_">rneg</span><span class="params">(rat q)</span> &#123;<span class="keyword">return</span> q.up=-q.up,q;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 求负*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrneg(q) lrneg(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 求负*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rneg(q) rneg(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*long rat减法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrminus(x,y) lrplus(x,lrneg(y))</span></span><br><span class="line">    <span class="comment">/*rat 减法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rminus(x,y) rplus(x,rneg(y))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 乘法*/</span></span><br><span class="line">lr <span class="title function_">lrtime</span><span class="params">(lr x,lr y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.splfd!=<span class="number">1</span>) x=lrsplfy(x);</span><br><span class="line">    <span class="keyword">if</span>(y.splfd!=<span class="number">1</span>) y=lrsplfy(y);</span><br><span class="line"><span class="comment">//  分母为零的无值分数。</span></span><br><span class="line">    <span class="keyword">if</span>(!x.down||!y.down)&#123;</span><br><span class="line"><span class="comment">//  这三行涉及复杂的分类讨论。</span></span><br><span class="line">        <span class="keyword">if</span>(!x.up||!y.up) <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">        <span class="keyword">if</span>(x.up&gt;<span class="number">0</span> ^ y.up&gt;<span class="number">0</span>) <span class="keyword">return</span> lrNEGINF;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lrINF; <span class="comment">//同号得正，异号得负。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  单独处理整数乘法。</span></span><br><span class="line">    <span class="keyword">if</span>(x.down==<span class="number">1</span>==y.down) <span class="keyword">return</span> x.up*=y.up,x;</span><br><span class="line">    ll temp;</span><br><span class="line">    <span class="keyword">if</span>(temp=gcd(x.up,y.down),temp!=<span class="number">1</span>)   x.up/=temp,y.down/=temp;</span><br><span class="line">    <span class="keyword">if</span>(temp=gcd(y.up,x.down),temp!=<span class="number">1</span>)   y.up/=temp,x.down/=temp;</span><br><span class="line">    x.up*=y.up;     x.down*=y.down;     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 乘法*/</span></span><br><span class="line">rat <span class="title function_">rtime</span><span class="params">(rat x,rat y)</span>&#123;</span><br><span class="line">    lr  xx=&#123;x.up,x.down,x.splfd&#125;,</span><br><span class="line">        yy=&#123;y.up,y.down,y.splfd&#125;;</span><br><span class="line">    xx=lrtime(xx,yy);</span><br><span class="line">    rat res=&#123;xx.up,xx.down,xx.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 乘法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrtime(x,y) lrtime(_LR_(x),_LR_(y))</span></span><br><span class="line">    <span class="comment">/*rat 乘法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rtime(x,y) rtime(_RAT_(x),_RAT_(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  认为无穷的倒数为0，0的倒数为正无穷，不定态的倒数为不定态。</span></span><br><span class="line">    <span class="comment">/*longrat 倒数*/</span></span><br><span class="line">lr <span class="title function_">lrflip</span><span class="params">(lr q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.splfd!=<span class="number">1</span>) lrsplfy(q);</span><br><span class="line">    <span class="type">char</span> minus=<span class="number">0</span>; ll temp;</span><br><span class="line"><span class="comment">//  鉴于分母类型为ull，引入minus记录正负性。</span></span><br><span class="line">    <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)</span><br><span class="line">        q.up=-q.up,minus=<span class="number">1</span>;</span><br><span class="line">    temp=q.up;</span><br><span class="line">    q.up=q.down;</span><br><span class="line">    q.down=temp;</span><br><span class="line">    <span class="keyword">if</span>(minus) q.up=-q.up;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 倒数*/</span></span><br><span class="line">rat <span class="title function_">rflip</span><span class="params">(rat q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.splfd!=<span class="number">1</span>) rsplfy(q);</span><br><span class="line">    <span class="type">char</span> minus=<span class="number">0</span>; <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)</span><br><span class="line">        q.up=-q.up,minus=<span class="number">1</span>;</span><br><span class="line">    temp=q.up;</span><br><span class="line">    q.up=q.down;</span><br><span class="line">    q.down=temp;</span><br><span class="line">    <span class="keyword">if</span>(minus) q.up=-q.up;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 倒数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrflip(q) lrflip(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 倒数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rflip(q) rflip(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 除法*/</span></span><br><span class="line">lr <span class="title function_">lrdivi</span><span class="params">(lr x,lr y)</span>&#123;</span><br><span class="line">    <span class="type">char</span> minus=<span class="number">0</span>; ll temp;</span><br><span class="line">    <span class="keyword">if</span>(y.up&lt;<span class="number">0</span>)</span><br><span class="line">        y.up=-y.up,minus=<span class="number">1</span>;</span><br><span class="line">    temp=y.up;</span><br><span class="line">    y.up=y.down;</span><br><span class="line">    y.down=temp;</span><br><span class="line">    <span class="keyword">if</span>(minus) y.up=-y.up;</span><br><span class="line">    <span class="keyword">return</span> lrtime(x,y);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 除法*/</span></span><br><span class="line">rat <span class="title function_">rdivi</span><span class="params">(rat x,rat y)</span>&#123;</span><br><span class="line">    <span class="type">char</span> minus=<span class="number">0</span>; <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(y.up&lt;<span class="number">0</span>)</span><br><span class="line">        y.up=-y.up,minus=<span class="number">1</span>;</span><br><span class="line">    temp=y.up;</span><br><span class="line">    y.up=y.down;</span><br><span class="line">    y.down=temp;</span><br><span class="line">    <span class="keyword">if</span>(minus) y.up=-y.up;</span><br><span class="line">    <span class="keyword">return</span> rtime(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 除法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrdivi(x,y) lrdivi(_LR_(x),_LR_(y))</span></span><br><span class="line">    <span class="comment">/*rat 除法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rdivi(x,y) rdivi(_RAT_(x),_RAT_(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  (char)ch可以取加减乘除号。</span></span><br><span class="line">    <span class="comment">/*calc of 2 longrats 运算包*/</span></span><br><span class="line">lr <span class="title function_">co2lr</span><span class="params">(lr x,<span class="type">char</span> ch,lr y)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">return</span> lrplus(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="keyword">return</span> lrminus(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">return</span> lrtime(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="keyword">return</span> lrdivi(x,y);</span><br><span class="line">        <span class="keyword">default</span> :<span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*calc of 2 rats 运算包*/</span></span><br><span class="line">rat <span class="title function_">co2r</span><span class="params">(rat x,<span class="type">char</span> ch,rat y)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">return</span> rplus(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="keyword">return</span> rminus(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">return</span> rtime(x,y);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="keyword">return</span> rdivi(x,y);</span><br><span class="line">        <span class="keyword">default</span> :<span class="keyword">return</span> rUNCERTAIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*calc of 2 longrats 运算包*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> co2lr(x,ch,y) co2lr(_LR_(x),ch,_LR_(y))</span></span><br><span class="line">    <span class="comment">/*calc of 2 rats 运算包*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> co2r(x,ch,y) co2r(_RAT_(x),ch,_RAT_(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*rat 绝对值*/</span></span><br><span class="line">rat <span class="title function_">rabs</span><span class="params">(rat q)</span></span><br><span class="line">    &#123;<span class="keyword">return</span> q.up&gt;=<span class="number">0</span> ? q:(q.up=-q.up,q);&#125;</span><br><span class="line">    <span class="comment">/*longrat 绝对值*/</span></span><br><span class="line">lr <span class="title function_">lrabs</span><span class="params">(lr q)</span></span><br><span class="line">    &#123;<span class="keyword">return</span> q.up&gt;=<span class="number">0</span> ? q:(q.up=-q.up,q);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 绝对值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrabs(q) lrabs(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 绝对值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rabs(q) rabs(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &quot;&gt;&quot;-&gt;1, &quot;==&quot;-&gt;0, &quot;&lt;&quot;-&gt;-1.</span></span><br><span class="line"><span class="comment">//  认为无穷和不定态等于自身，且不定态等于任何值。</span></span><br><span class="line">    <span class="comment">/*longrat 比较大小*/</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">lrcmp</span><span class="params">(lr x,lr y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.up&gt;<span class="number">0</span> ^ y.up&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x.up&gt;y.up ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//  以上防止出现不必要的计算和溢出。</span></span><br><span class="line">    ll res=lrminus(x,y).up;</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==res)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 比较大小*/</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">rcmp</span><span class="params">(rat x,rat y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.up&gt;<span class="number">0</span> ^ y.up&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x.up&gt;y.up ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//  以上防止出现不必要的计算和溢出。</span></span><br><span class="line">    <span class="type">int</span> res=rminus(x,y).up;</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==res)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 比较大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrcmp(x,y) lrcmp(_LR_(x),_LR_(y))</span></span><br><span class="line">    <span class="comment">/*rat 比较大小*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcmp(x,y) rcmp(_RAT_(x),_RAT_(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  longrat print，返回输出字符个数。</span></span><br><span class="line">    <span class="comment">/*longrat 分数输出*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">lrap</span><span class="params">(lr q)</span>&#123;</span><br><span class="line">    _RAP_CHECK_1_(q)</span><br><span class="line"><span class="comment">//  rapCHECK宏包含化简检查、无值分数输出。</span></span><br><span class="line">    <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)</span><br><span class="line">        q.up=-q.up,</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">        ++i;</span><br><span class="line">    _PUTU_PPI_(q.up,i)</span><br><span class="line">    <span class="keyword">if</span>(q.down==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//  分数线前后。</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;/&#x27;</span>); ++i;</span><br><span class="line">    _PUTU_PPI_(q.down,i)</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  rat print，返回输出字符个数。</span></span><br><span class="line">    <span class="comment">/*rat 分数输出*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">rap</span><span class="params">(rat q)</span>&#123;</span><br><span class="line">    lr qq=&#123;q.up,q.down,q.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> lrap(qq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 分数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrap(q) lrap(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 分数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rap(q) rap(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  float longrat print，返回输出字符个数。</span></span><br><span class="line">    <span class="comment">/*longrat 指定小数位数输出*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fltlrap</span><span class="params">(lr q,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    _RAP_CHECK_1_(q)</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; ll temp;</span><br><span class="line">    <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)</span><br><span class="line">        q.up=-q.up,</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span>(q.up&gt;=q.down)&#123;</span><br><span class="line">        temp=q.up/q.down;</span><br><span class="line">        _PUTU_PPI_(temp,i)</span><br><span class="line">        q.up%=q.down;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>),++i;</span><br><span class="line"><span class="comment">//  与下方的--n呼应，提速并剔除负精度。</span></span><br><span class="line">    <span class="keyword">if</span>(++n==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>) n=<span class="number">7</span>; <span class="comment">//遇负精度，输出六位。</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);++i;</span><br><span class="line">    <span class="keyword">while</span>(--n)</span><br><span class="line">        q.up*=<span class="number">10</span>,++i,</span><br><span class="line">        <span class="built_in">putchar</span>(q.up/q.down+<span class="string">&#x27;0&#x27;</span>),</span><br><span class="line">        q.up%=q.down;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 指定小数位数输出*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fltrap</span><span class="params">(rat q,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    lr qq=&#123;q.up,q.down,q.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> fltlrap(qq,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 指定小数位数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fltlrap(q,n) fltlrap(_LR_(q),n)</span></span><br><span class="line">    <span class="comment">/*rat 指定小数位数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fltrap(q,n) fltrap(_RAT_(q),n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回循环节长度，支持输出long long级长度的循环节。</span></span><br><span class="line">    <span class="comment">/*longrat 小数输出*/</span></span><br><span class="line">ll <span class="title function_">lrdeci</span><span class="params">(lr q)</span>&#123;</span><br><span class="line">    _RAP_CHECK_2_(q)</span><br><span class="line">    <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">        q.up=-q.up;</span><br><span class="line">    ull temp;</span><br><span class="line">    <span class="keyword">if</span>(q.up&gt;=q.down)&#123;</span><br><span class="line">        temp=q.up/q.down;</span><br><span class="line">        _PUTU_(temp)</span><br><span class="line">        q.up%=q.down;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!q.up) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    temp=q.down;</span><br><span class="line">    ll n1=<span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//  根据数论的结论，分母中包含因数5或2的个数，\</span></span><br><span class="line"><span class="comment">    决定了混循环小数的小数点与循环节间“废位”数。</span></span><br><span class="line">    <span class="keyword">while</span>(! (temp%<span class="number">5</span>))   ++n1,temp/=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(! (temp%<span class="number">2</span>))   ++n2,temp/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n2&gt;n1) n1=n2;    <span class="comment">//n1存放废位长度。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="number">0</span>;i&lt;n1;++i)&#123;</span><br><span class="line">        q.up*=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(q.up/q.down+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        q.up%=q.down;</span><br><span class="line">    &#125;   n1=q.up*<span class="number">10</span>;</span><br><span class="line"><span class="comment">//  发现是有限小数，截停。</span></span><br><span class="line">    <span class="keyword">if</span>(!(n1%q.down))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;(&#x27;</span>);   <span class="built_in">putchar</span>(n1/q.down+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    n1%=q.down;     n2=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//  q.up存放循环节首余数，n2记录循环节长度。</span></span><br><span class="line">    <span class="keyword">while</span>(n1!=q.up)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(n1*<span class="number">10</span>/q.down+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ++n2;</span><br><span class="line">        n1=n1*<span class="number">10</span>%q.down;</span><br><span class="line">    &#125;   <span class="built_in">putchar</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 小数输出*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdeci</span><span class="params">(rat q)</span>&#123;</span><br><span class="line">    lr qq=&#123;q.up,q.down,q.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> lrdeci(qq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 小数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrdeci(q) lrdeci(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 小数输出*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rdeci(q) rdeci(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  支持分数形式和（循环）小数形式，用 *英文* 括号标出循环节。</span></span><br><span class="line"><span class="comment">//  getlr丢弃前导空白符，开头若连续出现多个负号，则视为一个，\</span></span><br><span class="line"><span class="comment">    遇到 无关字符 或右括号&#x27;)&#x27;停止输入，不吸收无关字符，吸收&#x27;)&#x27;。</span></span><br><span class="line"><span class="comment">//  getlr支持小数点前后、分数线前后缺失。当分子或分母缺失时，\</span></span><br><span class="line"><span class="comment">    getlr默认它（们）为 *1*。遇到无效输入，getlr返回 不定态。\</span></span><br><span class="line"><span class="comment">    另外，getlr不支持&quot;inf&quot;&quot;+inf&quot;&quot;-inf&quot;&quot;NaN&quot;之类输入，请用\</span></span><br><span class="line"><span class="comment">    &quot;1/0&quot;&quot;-1/0&quot;&quot;0/0&quot;的分数形式代表它们。</span></span><br><span class="line"><span class="comment">//  为了提高效率，getlr()基于getchar()书写，不支持反斜线，不\</span></span><br><span class="line"><span class="comment">    支持全角数字，您也可以做修改。</span></span><br><span class="line">    <span class="comment">/*longrat 综合输入*/</span></span><br><span class="line">lr <span class="title function_">getlr</span><span class="params">()</span>&#123;</span><br><span class="line">    lr q=lrZERO; <span class="type">char</span> temp;</span><br><span class="line"><span class="comment">//  pozneg记录正负性，赋初值为1。</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> pozneg=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//  丢弃开头的空白字符，包括换行。</span></span><br><span class="line">    <span class="keyword">do</span> temp=getchar();</span><br><span class="line">    <span class="keyword">while</span>(_IS_BLANK_(temp));</span><br><span class="line">    _reset_:<span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: pozneg=<span class="number">-1</span>; temp=getchar(); <span class="keyword">goto</span> _reset_;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: <span class="keyword">goto</span> _afterpoint_;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: q.up=<span class="number">1</span>; <span class="keyword">goto</span> _afterslash_;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">if</span>(!_IS_DIGIT_(temp))&#123;</span><br><span class="line">            ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="comment">//  记录分子或整数部分，直到出现非数字。</span></span><br><span class="line">    _ADD_DIGIT_(q.up,temp)</span><br><span class="line"><span class="comment">//  遇到无关字符，整理正负性并输出。</span></span><br><span class="line">    _SHOULD_END_1_(q,temp)</span><br><span class="line"><span class="comment">//  如果遇到分数线……</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="string">&#x27;/&#x27;</span>)&#123; _afterslash_:;</span><br><span class="line">        <span class="type">signed</span> <span class="type">char</span> pzng=<span class="number">1</span>;</span><br><span class="line">        _reget_: temp=getchar();</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            &#123;pzng=<span class="number">-1</span>;<span class="keyword">goto</span> _reget_;&#125;</span><br><span class="line">        <span class="keyword">if</span>(_IS_DIGIT_(temp))</span><br><span class="line">            q.down=<span class="number">0</span>;</span><br><span class="line">        _ADD_DIGIT_(q.down,temp)</span><br><span class="line">        ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//  整理正负性。</span></span><br><span class="line">        <span class="keyword">if</span>(pozneg!=pzng)</span><br><span class="line">            q.up=-q.up;</span><br><span class="line"><span class="comment">//  强制化简。</span></span><br><span class="line">        q.splfd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> lrsplfy(q);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  如果遇到小数点……</span></span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="string">&#x27;.&#x27;</span>)&#123; _afterpoint_:;</span><br><span class="line">        lr qq=lrZERO;</span><br><span class="line">        ull down=<span class="number">1</span>;</span><br><span class="line">        temp=getchar();</span><br><span class="line"><span class="comment">//  记录非循环小数部分。</span></span><br><span class="line">        _POINT_ADD_DIGIT_(qq.up,down,temp)</span><br><span class="line">        qq.down=down;</span><br><span class="line">        qq.splfd=<span class="number">0</span>; <span class="comment">//须强制化简。</span></span><br><span class="line">        q=lrplus(q,qq);</span><br><span class="line"><span class="comment">//  遇到无关字符，整理正负性并输出。</span></span><br><span class="line">        _SHOULD_END_2_(q,temp)</span><br><span class="line"><span class="comment">//  遇到了左括号，还需要处理循环节。</span></span><br><span class="line">        qq=lrZERO;</span><br><span class="line">        temp=getchar();</span><br><span class="line">        _POINT_ADD_DIGIT_(qq.up,qq.down,temp)</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//  防止括号间无内容。</span></span><br><span class="line">        <span class="keyword">if</span>(qq.down!=<span class="number">1</span>)</span><br><span class="line"><span class="comment">//  为了衔接循环部分，down储存了数量级。</span></span><br><span class="line">            qq.down=(qq.down<span class="number">-1</span>)*down,</span><br><span class="line">            qq.splfd=<span class="number">0</span>,</span><br><span class="line">            q=lrplus(q,qq);</span><br><span class="line"><span class="comment">//  整理正负性，q已化简过。</span></span><br><span class="line">        q.up*=pozneg;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 综合输入*/</span></span><br><span class="line">rat <span class="title function_">getrat</span><span class="params">()</span>&#123;</span><br><span class="line">    lr qq=getlr();</span><br><span class="line">    rat q=&#123;qq.up,qq.down,qq.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  以下四个函数为功能分裂产物。</span></span><br><span class="line">    <span class="comment">/*longrat 分数输入*/</span></span><br><span class="line">lr <span class="title function_">getlfrac</span><span class="params">()</span>&#123;</span><br><span class="line">    lr q=lrZERO; <span class="type">char</span> temp;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> pozneg=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> temp=getchar();</span><br><span class="line">    <span class="keyword">while</span>(_IS_BLANK_(temp));</span><br><span class="line">    _reset_:<span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: pozneg=<span class="number">-1</span>; temp=getchar(); <span class="keyword">goto</span> _reset_;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: q.up=<span class="number">1</span>; <span class="keyword">goto</span> _afterslash_;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">if</span>(!_IS_DIGIT_(temp))&#123;</span><br><span class="line">            ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    _ADD_DIGIT_(q.up,temp)</span><br><span class="line">    _SHOULD_END_3_(q,temp)</span><br><span class="line"></span><br><span class="line">    _afterslash_:;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> pzng=<span class="number">1</span>;</span><br><span class="line">    _reget_: temp=getchar();</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;pzng=<span class="number">-1</span>;<span class="keyword">goto</span> _reget_;&#125;</span><br><span class="line">    <span class="keyword">if</span>(_IS_DIGIT_(temp))</span><br><span class="line">        q.down=<span class="number">0</span>;</span><br><span class="line">    _ADD_DIGIT_(q.down,temp)</span><br><span class="line">    ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(pozneg!=pzng)</span><br><span class="line">        q.up=-q.up;</span><br><span class="line">    q.splfd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> lrsplfy(q);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 分数输入*/</span></span><br><span class="line">rat <span class="title function_">getfrac</span><span class="params">()</span>&#123;</span><br><span class="line">    lr qq=getlfrac();</span><br><span class="line">    rat q=&#123;qq.up,qq.down,qq.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*longrat 小数输入*/</span></span><br><span class="line">lr <span class="title function_">getldeci</span><span class="params">()</span>&#123;</span><br><span class="line">    lr q=lrZERO; <span class="type">char</span> temp;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> pozneg=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> temp=getchar();</span><br><span class="line">    <span class="keyword">while</span>(_IS_BLANK_(temp));</span><br><span class="line">    _reset_:<span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: pozneg=<span class="number">-1</span>; temp=getchar(); <span class="keyword">goto</span> _reset_;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: <span class="keyword">goto</span> _afterpoint_;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">if</span>(!_IS_DIGIT_(temp))&#123;</span><br><span class="line">            ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">return</span> lrUNCERTAIN;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    _ADD_DIGIT_(q.up,temp)</span><br><span class="line">    _SHOULD_END_4_(q,temp)</span><br><span class="line"></span><br><span class="line">    _afterpoint_:;</span><br><span class="line">    lr qq=lrZERO;</span><br><span class="line">    ull down=<span class="number">1</span>;</span><br><span class="line">    temp=getchar();</span><br><span class="line">    _POINT_ADD_DIGIT_(qq.up,down,temp)</span><br><span class="line">    qq.down=down;</span><br><span class="line">    qq.splfd=<span class="number">0</span>;</span><br><span class="line">    q=lrplus(q,qq);</span><br><span class="line">    _SHOULD_END_2_(q,temp)</span><br><span class="line">    qq=lrZERO;</span><br><span class="line">    temp=getchar();</span><br><span class="line">    _POINT_ADD_DIGIT_(qq.up,qq.down,temp)</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    ungetc(temp,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(qq.down!=<span class="number">1</span>)</span><br><span class="line">    qq.down=(qq.down<span class="number">-1</span>)*down,</span><br><span class="line">    qq.splfd=<span class="number">0</span>,</span><br><span class="line">    q=lrplus(q,qq);</span><br><span class="line">    q.up*=pozneg;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*rat 小数输入*/</span></span><br><span class="line">rat <span class="title function_">getdeci</span><span class="params">()</span>&#123;</span><br><span class="line">    lr qq=getldeci();</span><br><span class="line">    rat q=&#123;qq.up,qq.down,qq.splfd&#125;;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*longrat 化为 double*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">lrtodb</span><span class="params">(lr q)</span></span><br><span class="line">    &#123;<span class="keyword">return</span> q.up/(<span class="type">double</span>)q.down;&#125;</span><br><span class="line">    <span class="comment">/*rat 化为 double*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">rattodb</span><span class="params">(rat q)</span></span><br><span class="line">    &#123;<span class="keyword">return</span> q.up/(<span class="type">double</span>)q.down;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 化为 double*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrtodb(q) lrtodb(_LR_(q))</span></span><br><span class="line">    <span class="comment">/*rat 化为 double*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rattodb(q) rattodb(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  以int边界代替所谓的无穷，认为rUNCERTAIN对应0。</span></span><br><span class="line">    <span class="comment">/*rat 化为整数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rattoint</span><span class="params">(rat q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.down)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.up)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.up&gt;<span class="number">0</span>)  <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)  <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.up/(<span class="type">int</span>)q.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*rat 化为整数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rattoint(q) rattoint(_RAT_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  以边界代替所谓的无穷，认为lrUNCERTAIN对应0。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &lt; LONG_MAX</span></span><br><span class="line">    <span class="comment">/*longrat 化为整数*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">lrtolong</span><span class="params">(lr q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.down)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.up)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.up&gt;<span class="number">0</span>)  <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">        <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)  <span class="keyword">return</span> LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.up/(<span class="type">long</span>)q.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 化为整数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrtolong(q) lrtolong(_LR_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/*longrat 化为整数*/</span></span><br><span class="line">ll <span class="title function_">lrtoll</span><span class="params">(lr q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.down)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.up)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q.up&gt;<span class="number">0</span>)  <span class="keyword">return</span> LONG_LONG_MAX;</span><br><span class="line">        <span class="keyword">if</span>(q.up&lt;<span class="number">0</span>)  <span class="keyword">return</span> LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.up/(ll)q.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AUTO_RAT_TYPE_</span></span><br><span class="line">    <span class="comment">/*longrat 化为整数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lrtoll(q) lrtoll(_LR_(q))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言库文件</category>
      </categories>
      <tags>
        <tag>分数</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2025/02/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h1><pre><code>单例模式（Singleton Pattern）是一种常见的设计模式，
用于确保一个类只有一个实例，并提供全局访问点。
在单例模式中，类的构造函数被私有化，确保外部无法直接创建对象实例。
同时，类内部定义一个静态成员变量用于保存唯一实例，并提供一个公共的静态方法用于获取该实例。
</code></pre>
<h2 id="饿汉模式-cpp语言实现"><a href="#饿汉模式-cpp语言实现" class="headerlink" title="饿汉模式(cpp语言实现)"></a><strong>饿汉模式</strong>(cpp语言实现)</h2><h3 id="饿汉模式是一种单例模式的实现方式，它在类加载时就创建实例，而不是在第一次使用时创建"><a href="#饿汉模式是一种单例模式的实现方式，它在类加载时就创建实例，而不是在第一次使用时创建" class="headerlink" title="饿汉模式是一种单例模式的实现方式，它在类加载时就创建实例，而不是在第一次使用时创建"></a>饿汉模式是一种单例模式的实现方式，它在类加载时就创建实例，而不是在第一次使用时创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MANAGER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MANAGER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Manager</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Manager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Manager</span>(<span class="type">const</span> Manager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Manager&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Manager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> T* manager;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Manager&lt;T&gt;::manager = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="懒汉模式-cpp语言实现"><a href="#懒汉模式-cpp语言实现" class="headerlink" title="懒汉模式(cpp语言实现)"></a><strong>懒汉模式</strong>(cpp语言实现)</h2><h3 id="懒汉模式是一种单例模式的实现方式，它在第一次使用时创建实例"><a href="#懒汉模式是一种单例模式的实现方式，它在第一次使用时创建实例" class="headerlink" title="懒汉模式是一种单例模式的实现方式，它在第一次使用时创建实例"></a>懒汉模式是一种单例模式的实现方式，它在第一次使用时创建实例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MANAGER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MANAGER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T* <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            manager = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Manager</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Manager</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Manager</span>(<span class="type">const</span> Manager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Manager&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Manager&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> T* manager;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Manager&lt;T&gt;::manager = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>瓦片地图</title>
    <url>/2025/02/03/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="瓦片地图设计-思路分享"><a href="#瓦片地图设计-思路分享" class="headerlink" title="瓦片地图设计(思路分享)"></a>瓦片地图设计(思路分享)</h1><ol>
<li>将一张地图理解为矩阵，矩阵的每个单元格就是瓦片类。</li>
<li>瓦片类中可以包含多种属性，可以利用这些属性绘制瓦片，再将瓦片烘焙成完整地图</li>
<li>瓦片地图的单元格属性可以使用csv文件存储</li>
</ol>
<h2 id="以下是是使用sdl绘制瓦片地图的cpp代码"><a href="#以下是是使用sdl绘制瓦片地图的cpp代码" class="headerlink" title="以下是是使用sdl绘制瓦片地图的cpp代码"></a>以下是是使用sdl绘制瓦片地图的cpp代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;route.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> std::unordered_map&lt;<span class="type">int</span>, Route&gt; SpawnerRoutePool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Map</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Map</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">std::ifstream <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!file.<span class="built_in">good</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		TileMap tile_map_temp;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> idx_x = <span class="number">-1</span>, idx_y = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		std::string str_line;</span><br><span class="line">		<span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, str_line))</span><br><span class="line">		&#123;</span><br><span class="line">			str_line = <span class="built_in">trim_str</span>(str_line);</span><br><span class="line">			<span class="keyword">if</span> (str_line.<span class="built_in">empty</span>())</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			idx_x = <span class="number">-1</span>, idx_y++;</span><br><span class="line">			tile_map_temp.<span class="built_in">emplace_back</span>();</span><br><span class="line"></span><br><span class="line">			std::string str_tile;</span><br><span class="line">			<span class="function">std::stringstream <span class="title">str_stream</span><span class="params">(str_line)</span></span>;</span><br><span class="line">			<span class="keyword">while</span> (std::<span class="built_in">getline</span>(str_stream, str_tile, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				idx_x++;</span><br><span class="line">				tile_map_temp[idx_y].<span class="built_in">emplace_back</span>();</span><br><span class="line">				Tile&amp; tile = tile_map_temp[idx_y].<span class="built_in">back</span>();</span><br><span class="line">				<span class="built_in">load_tile_from_string</span>(tile, str_tile);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tile_map_temp.<span class="built_in">empty</span>() || tile_map_temp[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		tile_map = tile_map_temp;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">generate_map_cache</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">get_width</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tile_map.<span class="built_in">empty</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tile_map[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">get_height</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> tile_map.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> TileMap&amp; <span class="title">get_tile_map</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> tile_map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> SDL_Point&amp; <span class="title">get_idx_home</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> idx_home;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> SpawnerRoutePool&amp; <span class="title">get_idx_spawner_pool</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> spwaner_route_pool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">place_tower</span><span class="params">(<span class="type">const</span> SDL_Point&amp; idx_tile)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tile_map[idx_tile.y][idx_tile.x].has_tower = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TileMap tile_map;</span><br><span class="line">	SDL_Point idx_home = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	SpawnerRoutePool spwaner_route_pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">trim_str</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">size_t</span> begin_idx = str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (begin_idx == std::string::npos)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">size_t</span> end_idx = str.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">		<span class="type">size_t</span> idx_range = end_idx - begin_idx + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> str.<span class="built_in">substr</span>(begin_idx, idx_range);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">load_tile_from_string</span><span class="params">(Tile&amp; tile, <span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::string str_tidy = <span class="built_in">trim_str</span>(str);</span><br><span class="line"></span><br><span class="line">		std::string str_value;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">		<span class="function">std::stringstream <span class="title">str_stream</span><span class="params">(str_tidy)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (std::<span class="built_in">getline</span>(str_stream, str_value, <span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				value = std::<span class="built_in">stoi</span>(str_value);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp;)</span><br><span class="line">			&#123;</span><br><span class="line">				value = <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			values.<span class="built_in">push_back</span>(value);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tile.terrian = (values.<span class="built_in">size</span>() &lt; <span class="number">1</span> || values[<span class="number">0</span>] &lt; <span class="number">0</span>) ? <span class="number">0</span> : values[<span class="number">0</span>];</span><br><span class="line">		tile.decoration = (values.<span class="built_in">size</span>() &lt; <span class="number">2</span>) ? <span class="number">-1</span> : values[<span class="number">1</span>];</span><br><span class="line">		tile.direction = (Tile::Direction)((values.<span class="built_in">size</span>() &lt; <span class="number">3</span> || values[<span class="number">2</span>] &lt; <span class="number">0</span>) ? <span class="number">0</span> : values[<span class="number">2</span>]);</span><br><span class="line">		tile.special_flag = (values.<span class="built_in">size</span>() &lt;= <span class="number">3</span>) ? <span class="number">-1</span> : values[<span class="number">3</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">generate_map_cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">get_height</span>(); y++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">get_width</span>(); x++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">const</span> Tile&amp; tile = tile_map[y][x];</span><br><span class="line">				<span class="keyword">if</span> (tile.special_flag &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (tile.special_flag == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					idx_home.x = x;</span><br><span class="line">					idx_home.y = y;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					spwaner_route_pool[tile.special_flag] = <span class="built_in">Route</span>(tile_map, &#123; x, y &#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_MAP_H_</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>SDL</tag>
        <tag>游戏开发</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>舍友的前端</title>
    <url>/2025/02/28/%E8%88%8D%E5%8F%8B%E7%9A%84%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Web</title>
</head>
<body>
    <h1>Hello HTML!!!</h1>
    <hr>
    <h2>作者: 张三</h2>
    <hr>
    <img src="../images/云边有个小卖部.jpg" height="500" width="500" alt="云边有个小卖部电影海报" title="云边有个小卖部电影海报">
    <hr>
    <B>
        《云边有个小卖部》拟结尾
    </B>

    <br>
    <audio src="../mixs/ _ 海洋Bo - 向云端.flac" controls></audio>
    <ul>
        <li>
            山风卷着咸涩的雨丝扑在小卖部的木门上，刘十三抱着膝盖坐在门槛上。外婆的摇椅还在老位置吱呀作响，竹篾编织的椅背还留着被烟头烫出的焦痕。
        </li>
        <br>
        <li>
            昨夜台风过境时镇上的狗叫得格外凄厉，此刻却安静得能听见屋檐滴水的声音。刘十三盯着货架上东倒西歪的玻璃汽水瓶，突然发现那台老式座钟的钟摆不知什么时候停了，时针凝固在凌晨三点。
        </li>
        <br>
        <li>
            "王莺莺！酱油放哪了？"他像过去二十年那样扯着嗓子喊，尾音却在空荡荡的屋里碎成齑粉。货架后的阴影里飘来淡淡的中药味，混着外婆常年抽的牡丹烟的气息。刘十三的指甲深深掐进掌心，直到货架最顶层的铁皮饼干盒"啪嗒"一声摔下来。
        </li>
        <br>
        <li>
            泛黄的诊断书从盒底滑出，像片枯叶落在他颤抖的膝盖上。肝癌晚期，确诊日期是去年立冬——比他醉酒那夜被外婆用拖拉机拉回云边镇还要早半个月。诊断书背面歪歪扭扭写着："臭小子房贷还剩23万，得活到把存折密码告诉他那天。"
        </li>
        <br>
        <li>
            门外传来细碎的脚步声，程霜举着把断了两根伞骨的油纸伞探进头来。她今天穿了件崭新的鹅黄连衣裙，裙摆被雨水晕染成深琥珀色。"明天我要去新加坡做手术了。"她蹲下来捡起滚落的陈皮糖，"这次要是能回来，你带我去看海好不好？"
        </li>
        <br>
        <li>
            刘十三把诊断书叠成小小的方块塞进衬衫口袋，起身从柜台底下摸出包未拆封的牡丹烟。打火机亮起的瞬间，他看见程霜苍白的脖颈上浮着淡青色的血管，像春雪下悄然流淌的溪水。"等你回来，我们把王莺莺的拖拉机开去海边。"
        </li>
        <br>
        <li>
            程霜走的时候把伞留在了门槛上。刘十三在积水的伞面上看到几滴暗红色，像落在宣纸上的朱砂。直到第七天黄昏，他收到个皱巴巴的航空信封，里面掉出张画着海浪的明信片，背面用荧光笔写着："海风吹起来的时候，记得替我尝尝是不是咸的。"
        </li>
        <br>
    </ul>
    <video src="../mixs/share_ba079ece51555ea3195eb139d63c63de.mp4" height="500" width="500" controls></video>
</body>
</html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇代码思路</title>
    <url>/2025/02/27/%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="贪吃蛇代码思路"><a href="#贪吃蛇代码思路" class="headerlink" title="贪吃蛇代码思路"></a>贪吃蛇代码思路</h1><ol>
<li>借助SDL图形API，采用单例模式，将整个游戏，UI，数据展示视为一个单例对象，没把蛇和地图弄成单例的原因是后面想做多人和多地形</li>
<li>game_maneger里的on_input函数为获取输入数据。on_updata为根据输入处理游戏数据，on_renderer为渲染函数</li>
<li>map.h的作用是作为瓦片地图存储地形数据，蛇和地图的数据是分离的，判断蛇是否撞到障碍物和蛇是否吃到食物是通过向map.h传入蛇头数据，所以才在snake.h里把map设为友元</li>
<li>map.h里有存储地形数据的临时数组，通过遍历数组来向真正的瓦片地图传入数据，所有地形的图片资源都在map文件加载获取，并获取对应纹理，释放图片表面。之后渲染瓦片时只需向瓦片的渲染函数中传入所需的图片纹理和渲染器，</li>
<li>蛇是一个双端队列，蛇的运动逻辑(Move()函数)为蛇尾坐标变成前一个蛇节的坐标，依次递归，蛇的增长逻辑 (UpdataLength()函数)为入队一个新蛇尾，这个蛇尾的坐标被初始化为原来蛇尾的坐标，再一次运动后，新蛇尾的坐标会变成旧蛇尾的坐标，旧蛇尾的坐标则会变成旧蛇尾前一个节点的坐标，实现新旧分离。</li>
<li>游戏通过SDL_Delay函数实现帧率固定为60帧，虽然蛇的更新频率为5次主循环一次数据更新，使得实际效果其实为12帧</li>
</ol>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/02/27/OpenGL/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
